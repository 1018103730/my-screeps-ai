# 移动及寻路设计案（设计阶段）

在开始移动时进行寻路（不搜索 creep），在移动时撞到了 creep 就进行对穿，撞到了墙就重新寻路。支持以下功能：

- 快速设置是否禁止/允许对穿
- 路径点移动
- 跨 shard 移动

# 对穿

在移动时保存上个位置，并在移动之后拿当前位置进行对比，如果位置相同就说明发生了“撞停“。发生撞停后会根据原本前进方向找到下个 RoomPosition，然后检查这个位置上是否有自己的 creep。如果没有，则重新规划寻路。如果有的话，向目标 creep 发起对穿请求，如果对方同意，则进行对穿。否则重新寻路。

# 路径点

如同红警、星际中的路径点一样，该功能可以使 creep 完成更复杂的远程寻路，creep 会先把第一个路径点当作寻路终点，抵达后在进行下一个寻路。在跨 shard 时这个功能尤为重要。可以通过将不同传送门配置成路径点的形式来完成在多个 shard 间跳跃。

路径点支持以下两种形式的配置：

- **位置字符串数组**：传入一个形如 `[ '12 21 E1N1 shard3', '12 21 E2N2 shard2', '12 21 E3N3 shard3' ]` 的字符串数组，一般用与在多个 shard 间移动。
- **路劲点旗帜**：传入一个旗帜前缀，如：`waypoint`。creep 会自动寻找 `waypoint1` 的旗帜当作第一个路径点，抵达后自动寻找 `waypoint2` 并移动 ...，直到找不到相同格式的旗帜为止。 

# 禁止通行点位

由于在工作中的 creep 会保持不动（例如 upgradeController），而此时如果有其他 Creep 发起对穿的话会使得它的工作返回 ERR_NOT_IN_RANGED，然后再对穿回来，就导致了两个 Creep 为了争夺工作位置一直对穿。为了解决该问题，引入了“禁止通行点位”概念。

该概念是指，在工作时的 creep 会将自己的位置设置为不可通行，得其他 creep 在寻路时会直接跳过该位置。并且，在工作时的 creep 也将拒绝对穿，从而避免了争抢工作位置的事情发生。

**申请禁止通行点位**

通过 `Room.addRestrictedPos()` 方法来申请一个禁止通行点位，申请点位需要申请 creep 的名字。

**获取禁止通行点位**

creep 在寻路时会自动调用 `Room.getRestrictedPos()` 来获取禁止通行点位，并进行绕过。

**释放禁止通行点位**

通过 `Room.removeRestrictedPos()` 来释放点位，释放点位只需要传入点位申请人的名字即可。

# 关于 processor

由于中央运输者所处的位置位于房间的中央，为了减轻交通压力，中央运输者将允许对穿。